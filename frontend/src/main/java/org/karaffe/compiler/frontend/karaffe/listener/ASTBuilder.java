package org.karaffe.compiler.frontend.karaffe.listener;

import org.antlr.v4.runtime.ANTLRErrorListener;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.atn.ATNConfigSet;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.TerminalNode;
import org.karaffe.compiler.base.pos.Position;
import org.karaffe.compiler.base.util.Platform;
import org.karaffe.compiler.frontend.karaffe.antlrautogenerated.KaraffeBaseListener;
import org.karaffe.compiler.frontend.karaffe.antlrautogenerated.KaraffeListener;
import org.karaffe.compiler.frontend.karaffe.antlrautogenerated.KaraffeParser;
import org.karaffe.compiler.frontend.karaffe.ast.CompilationUnit;
import org.karaffe.compiler.frontend.karaffe.ast.Parameter;
import org.karaffe.compiler.frontend.karaffe.ast.api.Expression;
import org.karaffe.compiler.frontend.karaffe.ast.api.Statement;
import org.karaffe.compiler.frontend.karaffe.ast.api.TypeDefMember;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.Apply;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.Div;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.IntLiteral;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.Minus;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.Mul;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.NewInstance;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.Plus;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.StaticApply;
import org.karaffe.compiler.frontend.karaffe.ast.modifiers.Public;
import org.karaffe.compiler.frontend.karaffe.ast.modifiers.Static;
import org.karaffe.compiler.frontend.karaffe.ast.names.SimpleName;
import org.karaffe.compiler.frontend.karaffe.ast.names.TypeName;
import org.karaffe.compiler.frontend.karaffe.ast.statements.ClassDef;
import org.karaffe.compiler.frontend.karaffe.ast.statements.MethodDef;
import org.karaffe.compiler.frontend.karaffe.transformer.util.TransformerContext;

import java.util.*;

public class ASTBuilder implements KaraffeListener, ANTLRErrorListener {
    private CompilationUnit compilationUnit = new CompilationUnit();

    private boolean hasError = false;

    private ClassDef currentClass;
    private MethodDef currentMethod;

    private final List<Statement> members = new ArrayList<>();
    private final Stack<Statement> stack = new Stack<>();

    private final TransformerContext context = TransformerContext.INSTANCE;
    private String currentSourceName = "";

    public ASTBuilder() {
    }

    public boolean hasElementInStack() {
        return !this.stack.isEmpty();
    }

    public Statement getStackPeek() {
        return this.stack.peek();
    }

    public CompilationUnit getCompilationUnit() {
        return compilationUnit;
    }

    public boolean hasError() {
        return hasError;
    }

    public void enterSourceFile(String sourceFileName) {
        this.currentSourceName = sourceFileName;
    }

    public void exitSourceFile() {
        this.currentSourceName = "";
    }

    @Override
    public void enterCompilationUnit(KaraffeParser.CompilationUnitContext ctx) {

    }

    @Override
    public void exitCompilationUnit(KaraffeParser.CompilationUnitContext ctx) {

    }

    @Override
    public void enterClassDefStmt(KaraffeParser.ClassDefStmtContext ctx) {

    }

    @Override
    public void exitClassDefStmt(KaraffeParser.ClassDefStmtContext ctx) {

    }

    @Override
    public void enterExprStmt(KaraffeParser.ExprStmtContext ctx) {

    }

    @Override
    public void exitExprStmt(KaraffeParser.ExprStmtContext ctx) {

    }

    @Override
    public void enterPrintExpr(KaraffeParser.PrintExprContext ctx) {

    }

    @Override
    public void exitPrintExpr(KaraffeParser.PrintExprContext ctx) {
        Expression expr = (Expression) stack.pop();
        stack.push(new StaticApply(getPosition(ctx), new TypeName("Console"), new SimpleName("println"), expr));
        members.add(stack.peek());
    }

    @Override
    public void enterMainStmt(KaraffeParser.MainStmtContext ctx) {

    }

    @Override
    public void exitMainStmt(KaraffeParser.MainStmtContext ctx) {
        MethodDef mainMethod = new MethodDef(
                Arrays.asList(new Public(), new Static()),
                TypeName.voidType(),
                new SimpleName("main"),
                Arrays.asList(new Parameter(new SimpleName("args"), new TypeName("String", true))));
        this.members.forEach(mainMethod::addMethodBody);
        this.members.clear();
        this.currentClass.addMember(mainMethod);
    }

    @Override
    public void enterClassDef(KaraffeParser.ClassDefContext ctx) {

    }

    @Override
    public void exitClassDef(KaraffeParser.ClassDefContext ctx) {

    }

    @Override
    public void enterClassDefMember(KaraffeParser.ClassDefMemberContext ctx) {
        this.members.clear();
    }

    @Override
    public void exitClassDefMember(KaraffeParser.ClassDefMemberContext ctx) {

    }

    @Override
    public void enterSimpleClassDef(KaraffeParser.SimpleClassDefContext ctx) {

    }

    @Override
    public void exitSimpleClassDef(KaraffeParser.SimpleClassDefContext ctx) {
        Position position = getPosition(ctx);
        KaraffeParser.IdentifierContext id = ctx.identifier();
        ClassDef classDef = new ClassDef(new SimpleName(id.getText()));
        classDef.resetPosition(position);
        classDef.replaceBody(this.members);
        this.members.clear();
        this.compilationUnit.addTypedefStatement(classDef);
    }

    @Override
    public void enterClassDefBody(KaraffeParser.ClassDefBodyContext ctx) {

    }

    @Override
    public void exitClassDefBody(KaraffeParser.ClassDefBodyContext ctx) {

    }

    @Override
    public void enterAddExpr(KaraffeParser.AddExprContext ctx) {

    }

    @Override
    public void exitMulExpr(KaraffeParser.MulExprContext ctx) {
        Expression right = (Expression) stack.pop();
        Expression left = (Expression) stack.pop();
        if (ctx.op.getText().equals("*")) {
            stack.push(new Apply(getPosition(ctx), left, new Mul(), right));
        } else if (ctx.op.getText().equals("/")) {
            stack.push(new Apply(getPosition(ctx), left, new Div(), right));
        } else {
            throw new IllegalStateException();
        }

    }

    @Override
    public void enterLiteral(KaraffeParser.LiteralContext ctx) {

    }

    @Override
    public void exitLiteral(KaraffeParser.LiteralContext ctx) {

    }

    @Override
    public void enterIdentifier(KaraffeParser.IdentifierContext ctx) {

    }

    @Override
    public void exitIdentifier(KaraffeParser.IdentifierContext ctx) {

    }

    @Override
    public void enterIntLiteral(KaraffeParser.IntLiteralContext ctx) {

    }

    @Override
    public void exitAddExpr(KaraffeParser.AddExprContext ctx) {
        Expression right = (Expression) stack.pop();
        Expression left = (Expression) stack.pop();
        if (ctx.op.getText().equals("+")) {
            stack.push(new Apply(getPosition(ctx), left, new Plus(), right));
        } else if (ctx.op.getText().equals("-")) {
            stack.push(new Apply(getPosition(ctx), left, new Minus(), right));
        } else {
            throw new IllegalStateException();
        }
    }

    @Override
    public void enterLit(KaraffeParser.LitContext ctx) {

    }

    @Override
    public void exitLit(KaraffeParser.LitContext ctx) {

    }

    @Override
    public void enterMulExpr(KaraffeParser.MulExprContext ctx) {

    }

    @Override
    public void exitIntLiteral(KaraffeParser.IntLiteralContext ctx) {
        try {
            int value = Integer.parseInt(ctx.getText());
            stack.push(new NewInstance(new TypeName("Int"), Collections.singletonList(new IntLiteral(getPosition(ctx), value))));
        } catch (NumberFormatException e) {
            //Token startToken = ctx.getStart();
            //Platform.stdErr("Syntax Error at " + startToken.getLine() + ":" + startToken.getCharPositionInLine() + " in " + startToken.getInputStream().getSourceName());
            this.hasError = true;
        }
    }

    @Override
    public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
        Platform.stdErr("Syntax Error at " + line + ":" + charPositionInLine + " in " + recognizer.getInputStream().getSourceName());
        Platform.stdErr(msg);
        this.hasError = true;
    }

    @Override
    public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs) {
        /* no op */
    }

    @Override
    public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {
        /* no op */
    }

    @Override
    public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs) {
        /* no op */
    }

    private Position getPosition(ParserRuleContext context) {
        Token startToken = context.getStart();
        return Position.of(startToken.getTokenSource().getSourceName(), startToken.getLine(), startToken.getCharPositionInLine());
    }

    @Override
    public void visitTerminal(TerminalNode node) {

    }

    @Override
    public void visitErrorNode(ErrorNode node) {

    }

    @Override
    public void enterEveryRule(ParserRuleContext ctx) {

    }

    @Override
    public void exitEveryRule(ParserRuleContext ctx) {

    }
}
