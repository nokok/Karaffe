package org.karaffe.compiler.frontend.karaffe.listener;

import org.antlr.v4.runtime.ANTLRErrorListener;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.atn.ATNConfigSet;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.tree.TerminalNode;
import org.karaffe.compiler.frontend.karaffe.antlrautogenerated.KaraffeBaseListener;
import org.karaffe.compiler.frontend.karaffe.antlrautogenerated.KaraffeParser;
import org.karaffe.compiler.frontend.karaffe.ast.CompilationUnit;
import org.karaffe.compiler.frontend.karaffe.ast.Parameter;
import org.karaffe.compiler.frontend.karaffe.ast.api.Expression;
import org.karaffe.compiler.frontend.karaffe.ast.api.Statement;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.*;
import org.karaffe.compiler.frontend.karaffe.ast.modifiers.Public;
import org.karaffe.compiler.frontend.karaffe.ast.modifiers.Static;
import org.karaffe.compiler.frontend.karaffe.ast.names.SimpleName;
import org.karaffe.compiler.frontend.karaffe.ast.names.TypeName;
import org.karaffe.compiler.frontend.karaffe.ast.statements.ClassDef;
import org.karaffe.compiler.frontend.karaffe.ast.statements.MethodDef;

import java.util.Arrays;
import java.util.BitSet;
import java.util.Stack;

public class ASTBuilder extends KaraffeBaseListener implements ANTLRErrorListener {
    private final CompilationUnit compilationUnit;

    private final MethodDef mainMethod;

    private boolean hasError = false;

    private final Stack<Statement> stack = new Stack<>();

    public ASTBuilder() {
        this.compilationUnit = new CompilationUnit();
        ClassDef mainClass = new ClassDef(new SimpleName("Main"), new TypeName("Object"));
        this.mainMethod = new MethodDef(
                Arrays.asList(new Public(), new Static()),
                TypeName.voidType(),
                new SimpleName("main"),
                Arrays.asList(new Parameter(new SimpleName("args"), new TypeName("String", true))));
        mainClass.addMember(mainMethod);
        this.compilationUnit.addTypedefStatement(mainClass);
    }

    public CompilationUnit getCompilationUnit() {
        stack.forEach(this.mainMethod::addMethodBody);
        stack.clear();
        return compilationUnit;
    }

    public boolean hasError() {
        return hasError;
    }

    @Override
    public void exitPrintExpr(KaraffeParser.PrintExprContext ctx) {
        Expression expr = (Expression) stack.pop();
        stack.push(new StaticApply(new TypeName("Console"), new SimpleName("println"), expr));
    }

    @Override
    public void exitMulExpr(KaraffeParser.MulExprContext ctx) {
        Expression right = (Expression) stack.pop();
        Expression left = (Expression) stack.pop();
        stack.push(new Apply(left, new Mul(), right));
    }

    @Override
    public void exitAddExpr(KaraffeParser.AddExprContext ctx) {
        Expression right = (Expression) stack.pop();
        Expression left = (Expression) stack.pop();
        stack.push(new Apply(left, new Plus(), right));
    }

    @Override
    public void exitIntLiteral(KaraffeParser.IntLiteralContext ctx) {
        stack.push(new IntLiteral(Integer.parseInt(ctx.getText())));
    }

    @Override
    public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
        System.err.println("Syntax Error at " + line + ":" + charPositionInLine + " in " + recognizer.getInputStream().getSourceName());
        System.err.println(msg);
        this.hasError = true;
    }

    @Override
    public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs) {
        /* no op */
    }

    @Override
    public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {
        /* no op */
    }

    @Override
    public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs) {
        /* no op */
    }
}
