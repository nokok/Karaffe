package org.karaffe.compiler.frontend.karaffe.listener;

import org.antlr.v4.runtime.ANTLRErrorListener;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.atn.ATNConfigSet;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.TerminalNode;
import org.karaffe.compiler.base.pos.Position;
import org.karaffe.compiler.base.util.Platform;
import org.karaffe.compiler.frontend.karaffe.antlrautogenerated.KaraffeBaseListener;
import org.karaffe.compiler.frontend.karaffe.antlrautogenerated.KaraffeParser;
import org.karaffe.compiler.frontend.karaffe.ast.CompilationUnit;
import org.karaffe.compiler.frontend.karaffe.ast.Parameter;
import org.karaffe.compiler.frontend.karaffe.ast.api.Expression;
import org.karaffe.compiler.frontend.karaffe.ast.api.Statement;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.Apply;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.Div;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.IntLiteral;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.Minus;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.Mul;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.NewInstance;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.Plus;
import org.karaffe.compiler.frontend.karaffe.ast.expressions.StaticApply;
import org.karaffe.compiler.frontend.karaffe.ast.modifiers.Public;
import org.karaffe.compiler.frontend.karaffe.ast.modifiers.Static;
import org.karaffe.compiler.frontend.karaffe.ast.names.SimpleName;
import org.karaffe.compiler.frontend.karaffe.ast.names.TypeName;
import org.karaffe.compiler.frontend.karaffe.ast.statements.ClassDef;
import org.karaffe.compiler.frontend.karaffe.ast.statements.MethodDef;

import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.Stack;

public class ASTBuilder extends KaraffeBaseListener implements ANTLRErrorListener {
    private final CompilationUnit compilationUnit;

    private final MethodDef mainMethod;

    private boolean hasError = false;

    private final Stack<Statement> stack = new Stack<>();

    private String currentSourceName = "";

    public ASTBuilder() {
        this.compilationUnit = new CompilationUnit();
        ClassDef mainClass = new ClassDef(new SimpleName("Main"), new TypeName("Object"));
        this.mainMethod = new MethodDef(
                Arrays.asList(new Public(), new Static()),
                TypeName.voidType(),
                new SimpleName("main"),
                Arrays.asList(new Parameter(new SimpleName("args"), new TypeName("String", true))));
        mainClass.addMember(mainMethod);
        this.compilationUnit.addTypedefStatement(mainClass);
    }

    public boolean hasElementInStack() {
        return !this.stack.isEmpty();
    }

    public Statement getStackPeek() {
        return this.stack.peek();
    }


    public CompilationUnit getCompilationUnit() {
        stack.forEach(this.mainMethod::addMethodBody);
        stack.clear();
        return compilationUnit;
    }

    public boolean hasError() {
        return hasError;
    }

    public void enterSourceFile(String sourceFileName) {
        this.currentSourceName = sourceFileName;
    }

    public void exitSourceFile() {
        this.currentSourceName = "";
    }

    @Override
    public void enterCompilationUnit(KaraffeParser.CompilationUnitContext ctx) {

    }

    @Override
    public void exitCompilationUnit(KaraffeParser.CompilationUnitContext ctx) {

    }

    @Override
    public void enterExprStmt(KaraffeParser.ExprStmtContext ctx) {

    }

    @Override
    public void exitExprStmt(KaraffeParser.ExprStmtContext ctx) {

    }

    @Override
    public void enterPrintExpr(KaraffeParser.PrintExprContext ctx) {

    }

    @Override
    public void exitPrintExpr(KaraffeParser.PrintExprContext ctx) {
        Expression expr = (Expression) stack.pop();
        stack.push(new StaticApply(getPosition(ctx), new TypeName("Console"), new SimpleName("println"), expr));
    }

    @Override
    public void enterAddExpr(KaraffeParser.AddExprContext ctx) {

    }

    @Override
    public void exitMulExpr(KaraffeParser.MulExprContext ctx) {
        Expression right = (Expression) stack.pop();
        Expression left = (Expression) stack.pop();
        if (ctx.op.getText().equals("*")) {
            stack.push(new Apply(getPosition(ctx), left, new Mul(), right));
        } else if (ctx.op.getText().equals("/")) {
            stack.push(new Apply(getPosition(ctx), left, new Div(), right));
        } else {
            throw new IllegalStateException();
        }

    }

    @Override
    public void enterLiteral(KaraffeParser.LiteralContext ctx) {

    }

    @Override
    public void exitLiteral(KaraffeParser.LiteralContext ctx) {

    }

    @Override
    public void enterIntLiteral(KaraffeParser.IntLiteralContext ctx) {

    }

    @Override
    public void exitAddExpr(KaraffeParser.AddExprContext ctx) {
        Expression right = (Expression) stack.pop();
        Expression left = (Expression) stack.pop();
        if (ctx.op.getText().equals("+")) {
            stack.push(new Apply(getPosition(ctx), left, new Plus(), right));
        } else if (ctx.op.getText().equals("-")) {
            stack.push(new Apply(getPosition(ctx), left, new Minus(), right));
        } else {
            throw new IllegalStateException();
        }
    }

    @Override
    public void enterLit(KaraffeParser.LitContext ctx) {

    }

    @Override
    public void exitLit(KaraffeParser.LitContext ctx) {

    }

    @Override
    public void enterMulExpr(KaraffeParser.MulExprContext ctx) {

    }

    @Override
    public void exitIntLiteral(KaraffeParser.IntLiteralContext ctx) {
        stack.push(new NewInstance(new TypeName("Int"), Collections.singletonList(new IntLiteral(getPosition(ctx), Integer.parseInt(ctx.getText())))));
    }

    @Override
    public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
        Platform.stdErr("Syntax Error at " + line + ":" + charPositionInLine + " in " + recognizer.getInputStream().getSourceName());
        Platform.stdErr(msg);
        this.hasError = true;
    }

    @Override
    public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs) {
        /* no op */
    }

    @Override
    public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {
        /* no op */
    }

    @Override
    public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs) {
        /* no op */
    }

    private Position getPosition(ParserRuleContext context) {
        Token startToken = context.getStart();
        return Position.of(startToken.getTokenSource().getSourceName(), startToken.getLine(), startToken.getCharPositionInLine());
    }

    @Override
    public void visitTerminal(TerminalNode node) {

    }

    @Override
    public void visitErrorNode(ErrorNode node) {

    }

    @Override
    public void enterEveryRule(ParserRuleContext ctx) {

    }

    @Override
    public void exitEveryRule(ParserRuleContext ctx) {

    }
}
